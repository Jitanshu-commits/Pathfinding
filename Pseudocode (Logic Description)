# Import necessary libraries                                                                 #Updates Pending.
import random  # Import the random module for shuffling neighbors in DFS
import pygame  # Import the pygame library for graphical visualization
import heapq  # Import the heapq module for priority queue implementation in Dijkstra's and A*
from collections import deque  # Import deque from collections for implementing the queue in BFS
import tkinter as tk  # Import tkinter as tk for creating GUI for algorithm selection
from tkinter import messagebox  # Import messagebox from tkinter for displaying message boxes in tkinter GUI

# Constants for algorithm selection
ASTAR = 1
DIJKSTRA = 2
BFS = 3
DFS = 4

# Constants                                                                                    
WHITE = (255, 255, 255)  # RGB values for white color
BLACK = (0, 0, 0)  # RGB values for black color
RED = (255, 0, 0)  # RGB values for red color
GREEN = (0, 255, 0)  # RGB values for green color
BLUE = (0, 0, 255)  # RGB values for blue color
YELLOW = (255, 255, 0)  # RGB values for yellow color
GRAY = (128, 128, 128)  # RGB values for gray color

GRID_SIZE = 20  # Number of cells in each row/column of the grid
CELL_SIZE = 30  # Size of each cell in pixels
SCREEN_SIZE = (GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE)  # Size of the Pygame window

# Initialize Pygame window
Create Pygame window with size SCREEN_SIZE
Set window caption to "Pathfinding Visualization"

# Function to draw the grid
Function draw_grid():
   # Loop to draw horizontal grid lines
    For each x-coordinate from 0 to SCREEN_SIZE[0] with step CELL_SIZE:
        Draw a line on the window with color WHITE from (x, 0) to (x, SCREEN_SIZE[1])
   # Loop to draw vertical grid lines
    For each y-coordinate from 0 to SCREEN_SIZE[1] with step CELL_SIZE:
        Draw a line on the window with color WHITE from (0, y) to (SCREEN_SIZE[0], y)

# Function to draw a colored cell at a specific position
Function draw_cell(color, position):
    Draw a rectangle on the window with specified color at position[0] * CELL_SIZE, position[1] * CELL_SIZE

# Function to visualize the path with a delay
Function visualize_path(path, color):
    For each cell in path:
        Draw the cell with the specified color on the window
        Update the window display
        Wait for 50 milliseconds

# Reset the screen, draw the grid, and update the display
Function reset():
    Fill the window with color BLACK
    Call draw_grid()
    Update the window display

# Dijkstra's algorithm
Function dijkstra(start, end, obstacles):
    Create an empty priority queue heap with initial element (0, start, [])
    Create an empty set visited

    While heap is not empty:
        Pop the element with the smallest cost, current position, and path from heap

        If current position is in visited:
            Continue to the next iteration

        Add current position to visited

        If current position is not the start or end, and not an obstacle:
            Draw the cell with color GREEN on the window

        If current position is the end:
            Call visualize_path with the current path and color YELLOW
            Return from the function

        For each neighbor in neighbors(current position):
            If neighbor is not in visited and not an obstacle:
                Push (cost + 1, neighbor, path + [current]) onto heap

        Update the window display

# A* algorithm
Function astar(start, end, obstacles):
    Create an empty priority queue heap with initial element (0, start, [])
    Create an empty set visited

    While heap is not empty:
        Pop the element with the smallest cost, current position, and path from heap

        If current position is in visited:
            Continue to the next iteration

        Add current position to visited

        If current position is not the start or end, and not an obstacle:
            Draw the cell with color BLUE on the window

        If current position is the end:
            Call visualize_path with the current path and color YELLOW
            Return from the function

        For each neighbor in neighbors(current position):
            If neighbor is not in visited and not an obstacle:
                Push (cost + 1 + heuristic(neighbor, end), neighbor, path + [current]) onto heap

        Update the window display

# DFS algorithm
Function dfs(start, end, obstacles):
    Create an empty stack with initial element (start, [])
    Create an empty set visited

    While stack is not empty:
        Pop the element with current position and path from stack

        If current position is in visited:
            Continue to the next iteration

        Add current position to visited

        If current position is not the start or end, and not an obstacle:
            Draw the cell with color BLUE on the window

        If current position is the end:
            Call visualize_path with the current path and color YELLOW
            Return from the function

        Shuffle the list of neighbors of the current position

        For each neighbor in the shuffled list:
            If neighbor is not in visited and not an obstacle:
                Push (neighbor, path + [current]) onto stack

        Update the window display

# BFS algorithm
Function bfs(start, end, obstacles):
    Create an empty queue with initial element (start, [])
    Create an empty set visited

    While queue is not empty:
        Dequeue the element with current position and path from queue

        If current position is in visited:
            Continue to the next iteration

        Add current position to visited

        If current position is not the start or end, and not an obstacle:
            Draw the cell with color BLUE on the window

        If current position is the end:
            Call visualize_path with the current path and color YELLOW
            Return from the function

        For each neighbor in neighbors(current position):
            If neighbor is not in visited and not an obstacle:
                Enqueue (neighbor, path + [current]) onto queue

        Update the window display
 
# Heuristic function for A*
Function heuristic(point, goal):
    Return the sum of absolute differences between point[0] and goal[0], and point[1] and goal[1]

# Function to get valid neighbors for a cell
Function neighbors(cell):
    Extract x and y from cell

    Initialize an empty list valid_neighbors

    If x > 0:
        Append (x - 1, y) to valid_neighbors
    If x < GRID_SIZE - 1:
        Append (x + 1, y) to valid_neighbors
    If y > 0:
        Append (x, y - 1) to valid_neighbors
    If y < GRID_SIZE - 1:
        Append (x, y + 1) to valid_neighbors

    Return valid_neighbors

# Function to remove an obstacle from the grid
Function remove_obstacle(cell, obstacles):
    If cell is in obstacles:
        Remove cell from obstacles
        Call draw_cell with color BLACK and cell
        Call draw_grid()
        Update the window display

# Main function
Function main():
    Call reset()

    Set running to true
    Set start_set to false
    Set end_set to false
    Set start to START
    Set end to END
    Create an empty set obstacles
    Set drawing_obstacle to false

    While running is true:
        For each event in pygame.event.get():
            If event type is QUIT:
                Set running to false
            Else if event type is KEYDOWN:
                If event key is SPACE:
                    If start_set is true and end_set is true:
                        Create empty paths dijkstra_path, astar_path, dfs_path, bfs_path

                        Record the start time for Dijkstra's algorithm
                        Call dijkstra with start, end, and obstacles
                        Record the end time for Dijkstra's algorithm
                        Print "Dijkstra's Algorithm Time:", end time - start time, "ms"

                        Record the start time for A* algorithm
                        Call astar with start, end, and obstacles
                        Record the end time for A* algorithm
                        Print "A* Algorithm Time:", end time - start time, "ms"

                        Record the start time for DFS algorithm
                        Call dfs with start, end, and obstacles
                        Record the end time for DFS algorithm
                        Print "DFS Algorithm Time:", end time - start time, "ms"

                        Record the start time for BFS algorithm
                        Call bfs with start, end, and obstacles
                        Record the end time for BFS algorithm
                        Print "BFS Algorithm Time:", end time - start time, "ms"
                Else if event key is C:
                    Set start_set to false
                    Set end_set to false
                    Set start to START
                    Set end to END
                    Create an empty set obstacles
                    Call reset()
            Else if event type is MOUSEBUTTONDOWN:
                Set pos to pygame.mouse.get_pos()
                Set cell_pos to (pos[0] // CELL_SIZE, pos[1] // CELL_SIZE)

                If start_set is false:
                    Set start to cell_pos
                    Call draw_cell with color RED and start
                    Set start_set to true
                Else if end_set is false and cell_pos is not equal to start:
                    Set end to cell_pos
                    Call draw_cell with color RED and end
                    Set end_set to true
                Else:
                    Add cell_pos to obstacles
                    Call draw_cell with color GRAY and cell_pos
                    Set drawing_obstacle to true
            Else if event type is MOUSEMOTION and drawing_obstacle is true:
                Set pos to pygame.mouse.get_pos()
                Set cell_pos to (pos[0] // CELL_SIZE, pos[1] // CELL_SIZE)
                Add cell_pos to obstacles
                Call draw_cell with color GRAY and cell_pos
            Else if event type is MOUSEBUTTONUP:
                Set drawing_obstacle to false

        Update the window display

    Call pygame.quit()

# Entry point
If __name__ is equal to "__main__":
    Call main()

If you want more detailed pseudocode for specific functions or sections, feel free to ask!
PS: I plan on adding new algorithms and some new functions(maze generation, grid resizing etc) that may change or make my previous codes/descs obsolete.
