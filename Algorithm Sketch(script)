#Taking major hits in algorithm performance, turns out adding more functions to algorithms slows the visiting process of cells (overall taking longer to find a path),
turning the algorithms to classes may help me reduce loops (make it efficient). I might do that to compare performance in future updates .

This Python script uses the Pygame library to visualize and compare Dijkstra's algorithm and A* algorithm for pathfinding in a grid-based environment. Here's a breakdown of the code:
(Additions- BFS ,DFS)
1. Import Statements

import random
import pygame
import heapq
from collections import deque
random: Module for generating pseudo-random numbers.
pygame: Library for creating games and multimedia applications.
heapq: Module for heap queue algorithm.
deque: Double-ended queue implementation for efficiently adding and removing elements.
2. Constants

# Color Constants
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
GRAY = (128, 128, 128)

# Grid Constants
GRID_SIZE = 20
CELL_SIZE = 30
SCREEN_SIZE = (GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE)

# Start and End Points
START = (0, 0)
END = (GRID_SIZE - 1, GRID_SIZE - 1)
Constants for colors and grid-related parameters.
3. Pygame Initialization

pygame.init()
screen = pygame.display.set_mode(SCREEN_SIZE)
pygame.display.set_caption("Pathfinding Visualization")
Initializes the Pygame library, creates a window with the specified size, and sets the window caption.
4. Drawing Functions
python

# Function to draw the grid
def draw_grid():
    # ...

# Function to draw a colored cell at a specific position
def draw_cell(color, position):
    # ...

# Function to visualize the path with a delay
def visualize_path(path, color):
    # ...

# Reset the screen, draw the grid, and update the display
def reset():
    # ...
5. Pathfinding Algorithms


# Dijkstra's algorithm
def dijkstra(start, end, obstacles):
    # ...

# A* algorithm
def astar(start, end, obstacles):
    # ...

# DFS algorithm
def dfs(start, end, obstacles):
    # ...

# BFS algorithm
def bfs(start, end, obstacles):
    # ...

# Heuristic function for A*
def heuristic(point, goal):
    # ...

# Function to get valid neighbors for a cell
def neighbors(cell):
    # ...
6. Main Function
python

def main():
    # ...

if __name__ == "__main__":
    main()
The main function initializes the screen, handles user input, and runs various pathfinding algorithms based on the user's actions.
7. User Interface and Input Handling
The code responds to user input events (e.g., mouse clicks, key presses) to set start and end points, draw obstacles, and initiate pathfinding algorithms.
8. Running Pathfinding Algorithms
When the user presses the spacebar (pygame.K_SPACE), Dijkstra's, A*, DFS, and BFS algorithms are run simultaneously, and the time taken by each algorithm is printed.
9. Pygame Event Loop
The program enters a Pygame event loop (pygame.event.get()) to handle user input, update the display, and keep the application running until the user closes the window (pygame.QUIT event).
10. Obstacle Drawing
The code allows users to draw obstacles on the grid by clicking and dragging the mouse.
11. Cleanup


pygame.quit()
Properly shuts down the Pygame library when the program exits.

The main function is called if the script is executed directly.
The script allows the user to set start and end points, mark cells as obstacles, and compare Dijkstra's and A* algorithms in finding the shortest path.

Note: Make sure to have the Pygame library installed (pip install pygame) before running this script.
PS: I plan on adding new algos and some new functions(maze generation, grid resizing etc) that may change or make my previous codes/descs obsolete.
(I want a new GUI pls help)


